//
// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the protocol buffer compiler.
// Source: myProto.proto
//
import GRPC
import NIO
import NIOConcurrencyHelpers
import SwiftProtobuf


/// Usage: instantiate `MyProto_MessageServiceClient`, then call methods of this protocol to make API calls.
internal protocol MyProto_MessageServiceClientProtocol: GRPCClient {
  var serviceName: String { get }
  var interceptors: MyProto_MessageServiceClientInterceptorFactoryProtocol? { get }

  func connect(
    _ request: MyProto_Empty,
    callOptions: CallOptions?
  ) -> UnaryCall<MyProto_Empty, MyProto_User>

  func disconnect(
    _ request: MyProto_User,
    callOptions: CallOptions?
  ) -> UnaryCall<MyProto_User, MyProto_Empty>

  func sendMessage(
    _ request: MyProto_Message,
    callOptions: CallOptions?
  ) -> UnaryCall<MyProto_Message, MyProto_Empty>

  func sendPlay(
    _ request: MyProto_Play,
    callOptions: CallOptions?
  ) -> UnaryCall<MyProto_Play, MyProto_Empty>

  func updateSessionStatus(
    _ request: MyProto_User,
    callOptions: CallOptions?,
    handler: @escaping (MyProto_SessionStatus) -> Void
  ) -> ServerStreamingCall<MyProto_User, MyProto_SessionStatus>

  func updateMessages(
    _ request: MyProto_User,
    callOptions: CallOptions?,
    handler: @escaping (MyProto_Message) -> Void
  ) -> ServerStreamingCall<MyProto_User, MyProto_Message>

  func updateBoard(
    _ request: MyProto_User,
    callOptions: CallOptions?,
    handler: @escaping (MyProto_Board) -> Void
  ) -> ServerStreamingCall<MyProto_User, MyProto_Board>

  func updateTurn(
    _ request: MyProto_User,
    callOptions: CallOptions?,
    handler: @escaping (MyProto_User) -> Void
  ) -> ServerStreamingCall<MyProto_User, MyProto_User>

  func updateGameStatus(
    _ request: MyProto_User,
    callOptions: CallOptions?,
    handler: @escaping (MyProto_GameStatus) -> Void
  ) -> ServerStreamingCall<MyProto_User, MyProto_GameStatus>
}

extension MyProto_MessageServiceClientProtocol {
  internal var serviceName: String {
    return "myProto.MessageService"
  }

  /// Unary call to connect
  ///
  /// - Parameters:
  ///   - request: Request to send to connect.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func connect(
    _ request: MyProto_Empty,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<MyProto_Empty, MyProto_User> {
    return self.makeUnaryCall(
      path: MyProto_MessageServiceClientMetadata.Methods.connect.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeconnectInterceptors() ?? []
    )
  }

  /// Unary call to disconnect
  ///
  /// - Parameters:
  ///   - request: Request to send to disconnect.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func disconnect(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<MyProto_User, MyProto_Empty> {
    return self.makeUnaryCall(
      path: MyProto_MessageServiceClientMetadata.Methods.disconnect.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makedisconnectInterceptors() ?? []
    )
  }

  /// Unary call to sendMessage
  ///
  /// - Parameters:
  ///   - request: Request to send to sendMessage.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func sendMessage(
    _ request: MyProto_Message,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<MyProto_Message, MyProto_Empty> {
    return self.makeUnaryCall(
      path: MyProto_MessageServiceClientMetadata.Methods.sendMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesendMessageInterceptors() ?? []
    )
  }

  /// Unary call to sendPlay
  ///
  /// - Parameters:
  ///   - request: Request to send to sendPlay.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  internal func sendPlay(
    _ request: MyProto_Play,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<MyProto_Play, MyProto_Empty> {
    return self.makeUnaryCall(
      path: MyProto_MessageServiceClientMetadata.Methods.sendPlay.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesendPlayInterceptors() ?? []
    )
  }

  /// Server streaming call to updateSessionStatus
  ///
  /// - Parameters:
  ///   - request: Request to send to updateSessionStatus.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func updateSessionStatus(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil,
    handler: @escaping (MyProto_SessionStatus) -> Void
  ) -> ServerStreamingCall<MyProto_User, MyProto_SessionStatus> {
    return self.makeServerStreamingCall(
      path: MyProto_MessageServiceClientMetadata.Methods.updateSessionStatus.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateSessionStatusInterceptors() ?? [],
      handler: handler
    )
  }

  /// Server streaming call to updateMessages
  ///
  /// - Parameters:
  ///   - request: Request to send to updateMessages.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func updateMessages(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil,
    handler: @escaping (MyProto_Message) -> Void
  ) -> ServerStreamingCall<MyProto_User, MyProto_Message> {
    return self.makeServerStreamingCall(
      path: MyProto_MessageServiceClientMetadata.Methods.updateMessages.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateMessagesInterceptors() ?? [],
      handler: handler
    )
  }

  /// Server streaming call to updateBoard
  ///
  /// - Parameters:
  ///   - request: Request to send to updateBoard.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func updateBoard(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil,
    handler: @escaping (MyProto_Board) -> Void
  ) -> ServerStreamingCall<MyProto_User, MyProto_Board> {
    return self.makeServerStreamingCall(
      path: MyProto_MessageServiceClientMetadata.Methods.updateBoard.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateBoardInterceptors() ?? [],
      handler: handler
    )
  }

  /// Server streaming call to updateTurn
  ///
  /// - Parameters:
  ///   - request: Request to send to updateTurn.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func updateTurn(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil,
    handler: @escaping (MyProto_User) -> Void
  ) -> ServerStreamingCall<MyProto_User, MyProto_User> {
    return self.makeServerStreamingCall(
      path: MyProto_MessageServiceClientMetadata.Methods.updateTurn.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateTurnInterceptors() ?? [],
      handler: handler
    )
  }

  /// Server streaming call to updateGameStatus
  ///
  /// - Parameters:
  ///   - request: Request to send to updateGameStatus.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  internal func updateGameStatus(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil,
    handler: @escaping (MyProto_GameStatus) -> Void
  ) -> ServerStreamingCall<MyProto_User, MyProto_GameStatus> {
    return self.makeServerStreamingCall(
      path: MyProto_MessageServiceClientMetadata.Methods.updateGameStatus.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateGameStatusInterceptors() ?? [],
      handler: handler
    )
  }
}

@available(*, deprecated)
extension MyProto_MessageServiceClient: @unchecked Sendable {}

@available(*, deprecated, renamed: "MyProto_MessageServiceNIOClient")
internal final class MyProto_MessageServiceClient: MyProto_MessageServiceClientProtocol {
  private let lock = Lock()
  private var _defaultCallOptions: CallOptions
  private var _interceptors: MyProto_MessageServiceClientInterceptorFactoryProtocol?
  internal let channel: GRPCChannel
  internal var defaultCallOptions: CallOptions {
    get { self.lock.withLock { return self._defaultCallOptions } }
    set { self.lock.withLockVoid { self._defaultCallOptions = newValue } }
  }
  internal var interceptors: MyProto_MessageServiceClientInterceptorFactoryProtocol? {
    get { self.lock.withLock { return self._interceptors } }
    set { self.lock.withLockVoid { self._interceptors = newValue } }
  }

  /// Creates a client for the myProto.MessageService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: MyProto_MessageServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self._defaultCallOptions = defaultCallOptions
    self._interceptors = interceptors
  }
}

internal struct MyProto_MessageServiceNIOClient: MyProto_MessageServiceClientProtocol {
  internal var channel: GRPCChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: MyProto_MessageServiceClientInterceptorFactoryProtocol?

  /// Creates a client for the myProto.MessageService service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  ///   - interceptors: A factory providing interceptors for each RPC.
  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: MyProto_MessageServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal protocol MyProto_MessageServiceAsyncClientProtocol: GRPCClient {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: MyProto_MessageServiceClientInterceptorFactoryProtocol? { get }

  func makeConnectCall(
    _ request: MyProto_Empty,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<MyProto_Empty, MyProto_User>

  func makeDisconnectCall(
    _ request: MyProto_User,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<MyProto_User, MyProto_Empty>

  func makeSendMessageCall(
    _ request: MyProto_Message,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<MyProto_Message, MyProto_Empty>

  func makeSendPlayCall(
    _ request: MyProto_Play,
    callOptions: CallOptions?
  ) -> GRPCAsyncUnaryCall<MyProto_Play, MyProto_Empty>

  func makeUpdateSessionStatusCall(
    _ request: MyProto_User,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<MyProto_User, MyProto_SessionStatus>

  func makeUpdateMessagesCall(
    _ request: MyProto_User,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<MyProto_User, MyProto_Message>

  func makeUpdateBoardCall(
    _ request: MyProto_User,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<MyProto_User, MyProto_Board>

  func makeUpdateTurnCall(
    _ request: MyProto_User,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<MyProto_User, MyProto_User>

  func makeUpdateGameStatusCall(
    _ request: MyProto_User,
    callOptions: CallOptions?
  ) -> GRPCAsyncServerStreamingCall<MyProto_User, MyProto_GameStatus>
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension MyProto_MessageServiceAsyncClientProtocol {
  internal static var serviceDescriptor: GRPCServiceDescriptor {
    return MyProto_MessageServiceClientMetadata.serviceDescriptor
  }

  internal var interceptors: MyProto_MessageServiceClientInterceptorFactoryProtocol? {
    return nil
  }

  internal func makeConnectCall(
    _ request: MyProto_Empty,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<MyProto_Empty, MyProto_User> {
    return self.makeAsyncUnaryCall(
      path: MyProto_MessageServiceClientMetadata.Methods.connect.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeconnectInterceptors() ?? []
    )
  }

  internal func makeDisconnectCall(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<MyProto_User, MyProto_Empty> {
    return self.makeAsyncUnaryCall(
      path: MyProto_MessageServiceClientMetadata.Methods.disconnect.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makedisconnectInterceptors() ?? []
    )
  }

  internal func makeSendMessageCall(
    _ request: MyProto_Message,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<MyProto_Message, MyProto_Empty> {
    return self.makeAsyncUnaryCall(
      path: MyProto_MessageServiceClientMetadata.Methods.sendMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesendMessageInterceptors() ?? []
    )
  }

  internal func makeSendPlayCall(
    _ request: MyProto_Play,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncUnaryCall<MyProto_Play, MyProto_Empty> {
    return self.makeAsyncUnaryCall(
      path: MyProto_MessageServiceClientMetadata.Methods.sendPlay.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesendPlayInterceptors() ?? []
    )
  }

  internal func makeUpdateSessionStatusCall(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<MyProto_User, MyProto_SessionStatus> {
    return self.makeAsyncServerStreamingCall(
      path: MyProto_MessageServiceClientMetadata.Methods.updateSessionStatus.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateSessionStatusInterceptors() ?? []
    )
  }

  internal func makeUpdateMessagesCall(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<MyProto_User, MyProto_Message> {
    return self.makeAsyncServerStreamingCall(
      path: MyProto_MessageServiceClientMetadata.Methods.updateMessages.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateMessagesInterceptors() ?? []
    )
  }

  internal func makeUpdateBoardCall(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<MyProto_User, MyProto_Board> {
    return self.makeAsyncServerStreamingCall(
      path: MyProto_MessageServiceClientMetadata.Methods.updateBoard.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateBoardInterceptors() ?? []
    )
  }

  internal func makeUpdateTurnCall(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<MyProto_User, MyProto_User> {
    return self.makeAsyncServerStreamingCall(
      path: MyProto_MessageServiceClientMetadata.Methods.updateTurn.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateTurnInterceptors() ?? []
    )
  }

  internal func makeUpdateGameStatusCall(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncServerStreamingCall<MyProto_User, MyProto_GameStatus> {
    return self.makeAsyncServerStreamingCall(
      path: MyProto_MessageServiceClientMetadata.Methods.updateGameStatus.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateGameStatusInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension MyProto_MessageServiceAsyncClientProtocol {
  internal func connect(
    _ request: MyProto_Empty,
    callOptions: CallOptions? = nil
  ) async throws -> MyProto_User {
    return try await self.performAsyncUnaryCall(
      path: MyProto_MessageServiceClientMetadata.Methods.connect.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeconnectInterceptors() ?? []
    )
  }

  internal func disconnect(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil
  ) async throws -> MyProto_Empty {
    return try await self.performAsyncUnaryCall(
      path: MyProto_MessageServiceClientMetadata.Methods.disconnect.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makedisconnectInterceptors() ?? []
    )
  }

  internal func sendMessage(
    _ request: MyProto_Message,
    callOptions: CallOptions? = nil
  ) async throws -> MyProto_Empty {
    return try await self.performAsyncUnaryCall(
      path: MyProto_MessageServiceClientMetadata.Methods.sendMessage.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesendMessageInterceptors() ?? []
    )
  }

  internal func sendPlay(
    _ request: MyProto_Play,
    callOptions: CallOptions? = nil
  ) async throws -> MyProto_Empty {
    return try await self.performAsyncUnaryCall(
      path: MyProto_MessageServiceClientMetadata.Methods.sendPlay.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makesendPlayInterceptors() ?? []
    )
  }

  internal func updateSessionStatus(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<MyProto_SessionStatus> {
    return self.performAsyncServerStreamingCall(
      path: MyProto_MessageServiceClientMetadata.Methods.updateSessionStatus.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateSessionStatusInterceptors() ?? []
    )
  }

  internal func updateMessages(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<MyProto_Message> {
    return self.performAsyncServerStreamingCall(
      path: MyProto_MessageServiceClientMetadata.Methods.updateMessages.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateMessagesInterceptors() ?? []
    )
  }

  internal func updateBoard(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<MyProto_Board> {
    return self.performAsyncServerStreamingCall(
      path: MyProto_MessageServiceClientMetadata.Methods.updateBoard.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateBoardInterceptors() ?? []
    )
  }

  internal func updateTurn(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<MyProto_User> {
    return self.performAsyncServerStreamingCall(
      path: MyProto_MessageServiceClientMetadata.Methods.updateTurn.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateTurnInterceptors() ?? []
    )
  }

  internal func updateGameStatus(
    _ request: MyProto_User,
    callOptions: CallOptions? = nil
  ) -> GRPCAsyncResponseStream<MyProto_GameStatus> {
    return self.performAsyncServerStreamingCall(
      path: MyProto_MessageServiceClientMetadata.Methods.updateGameStatus.path,
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      interceptors: self.interceptors?.makeupdateGameStatusInterceptors() ?? []
    )
  }
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal struct MyProto_MessageServiceAsyncClient: MyProto_MessageServiceAsyncClientProtocol {
  internal var channel: GRPCChannel
  internal var defaultCallOptions: CallOptions
  internal var interceptors: MyProto_MessageServiceClientInterceptorFactoryProtocol?

  internal init(
    channel: GRPCChannel,
    defaultCallOptions: CallOptions = CallOptions(),
    interceptors: MyProto_MessageServiceClientInterceptorFactoryProtocol? = nil
  ) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
    self.interceptors = interceptors
  }
}

internal protocol MyProto_MessageServiceClientInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when invoking 'connect'.
  func makeconnectInterceptors() -> [ClientInterceptor<MyProto_Empty, MyProto_User>]

  /// - Returns: Interceptors to use when invoking 'disconnect'.
  func makedisconnectInterceptors() -> [ClientInterceptor<MyProto_User, MyProto_Empty>]

  /// - Returns: Interceptors to use when invoking 'sendMessage'.
  func makesendMessageInterceptors() -> [ClientInterceptor<MyProto_Message, MyProto_Empty>]

  /// - Returns: Interceptors to use when invoking 'sendPlay'.
  func makesendPlayInterceptors() -> [ClientInterceptor<MyProto_Play, MyProto_Empty>]

  /// - Returns: Interceptors to use when invoking 'updateSessionStatus'.
  func makeupdateSessionStatusInterceptors() -> [ClientInterceptor<MyProto_User, MyProto_SessionStatus>]

  /// - Returns: Interceptors to use when invoking 'updateMessages'.
  func makeupdateMessagesInterceptors() -> [ClientInterceptor<MyProto_User, MyProto_Message>]

  /// - Returns: Interceptors to use when invoking 'updateBoard'.
  func makeupdateBoardInterceptors() -> [ClientInterceptor<MyProto_User, MyProto_Board>]

  /// - Returns: Interceptors to use when invoking 'updateTurn'.
  func makeupdateTurnInterceptors() -> [ClientInterceptor<MyProto_User, MyProto_User>]

  /// - Returns: Interceptors to use when invoking 'updateGameStatus'.
  func makeupdateGameStatusInterceptors() -> [ClientInterceptor<MyProto_User, MyProto_GameStatus>]
}

internal enum MyProto_MessageServiceClientMetadata {
  internal static let serviceDescriptor = GRPCServiceDescriptor(
    name: "MessageService",
    fullName: "myProto.MessageService",
    methods: [
      MyProto_MessageServiceClientMetadata.Methods.connect,
      MyProto_MessageServiceClientMetadata.Methods.disconnect,
      MyProto_MessageServiceClientMetadata.Methods.sendMessage,
      MyProto_MessageServiceClientMetadata.Methods.sendPlay,
      MyProto_MessageServiceClientMetadata.Methods.updateSessionStatus,
      MyProto_MessageServiceClientMetadata.Methods.updateMessages,
      MyProto_MessageServiceClientMetadata.Methods.updateBoard,
      MyProto_MessageServiceClientMetadata.Methods.updateTurn,
      MyProto_MessageServiceClientMetadata.Methods.updateGameStatus,
    ]
  )

  internal enum Methods {
    internal static let connect = GRPCMethodDescriptor(
      name: "connect",
      path: "/myProto.MessageService/connect",
      type: GRPCCallType.unary
    )

    internal static let disconnect = GRPCMethodDescriptor(
      name: "disconnect",
      path: "/myProto.MessageService/disconnect",
      type: GRPCCallType.unary
    )

    internal static let sendMessage = GRPCMethodDescriptor(
      name: "sendMessage",
      path: "/myProto.MessageService/sendMessage",
      type: GRPCCallType.unary
    )

    internal static let sendPlay = GRPCMethodDescriptor(
      name: "sendPlay",
      path: "/myProto.MessageService/sendPlay",
      type: GRPCCallType.unary
    )

    internal static let updateSessionStatus = GRPCMethodDescriptor(
      name: "updateSessionStatus",
      path: "/myProto.MessageService/updateSessionStatus",
      type: GRPCCallType.serverStreaming
    )

    internal static let updateMessages = GRPCMethodDescriptor(
      name: "updateMessages",
      path: "/myProto.MessageService/updateMessages",
      type: GRPCCallType.serverStreaming
    )

    internal static let updateBoard = GRPCMethodDescriptor(
      name: "updateBoard",
      path: "/myProto.MessageService/updateBoard",
      type: GRPCCallType.serverStreaming
    )

    internal static let updateTurn = GRPCMethodDescriptor(
      name: "updateTurn",
      path: "/myProto.MessageService/updateTurn",
      type: GRPCCallType.serverStreaming
    )

    internal static let updateGameStatus = GRPCMethodDescriptor(
      name: "updateGameStatus",
      path: "/myProto.MessageService/updateGameStatus",
      type: GRPCCallType.serverStreaming
    )
  }
}

/// To build a server, implement a class that conforms to this protocol.
internal protocol MyProto_MessageServiceProvider: CallHandlerProvider {
  var interceptors: MyProto_MessageServiceServerInterceptorFactoryProtocol? { get }

  func connect(request: MyProto_Empty, context: StatusOnlyCallContext) -> EventLoopFuture<MyProto_User>

  func disconnect(request: MyProto_User, context: StatusOnlyCallContext) -> EventLoopFuture<MyProto_Empty>

  func sendMessage(request: MyProto_Message, context: StatusOnlyCallContext) -> EventLoopFuture<MyProto_Empty>

  func sendPlay(request: MyProto_Play, context: StatusOnlyCallContext) -> EventLoopFuture<MyProto_Empty>

  func updateSessionStatus(request: MyProto_User, context: StreamingResponseCallContext<MyProto_SessionStatus>) -> EventLoopFuture<GRPCStatus>

  func updateMessages(request: MyProto_User, context: StreamingResponseCallContext<MyProto_Message>) -> EventLoopFuture<GRPCStatus>

  func updateBoard(request: MyProto_User, context: StreamingResponseCallContext<MyProto_Board>) -> EventLoopFuture<GRPCStatus>

  func updateTurn(request: MyProto_User, context: StreamingResponseCallContext<MyProto_User>) -> EventLoopFuture<GRPCStatus>

  func updateGameStatus(request: MyProto_User, context: StreamingResponseCallContext<MyProto_GameStatus>) -> EventLoopFuture<GRPCStatus>
}

extension MyProto_MessageServiceProvider {
  internal var serviceName: Substring {
    return MyProto_MessageServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "connect":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_Empty>(),
        responseSerializer: ProtobufSerializer<MyProto_User>(),
        interceptors: self.interceptors?.makeconnectInterceptors() ?? [],
        userFunction: self.connect(request:context:)
      )

    case "disconnect":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_User>(),
        responseSerializer: ProtobufSerializer<MyProto_Empty>(),
        interceptors: self.interceptors?.makedisconnectInterceptors() ?? [],
        userFunction: self.disconnect(request:context:)
      )

    case "sendMessage":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_Message>(),
        responseSerializer: ProtobufSerializer<MyProto_Empty>(),
        interceptors: self.interceptors?.makesendMessageInterceptors() ?? [],
        userFunction: self.sendMessage(request:context:)
      )

    case "sendPlay":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_Play>(),
        responseSerializer: ProtobufSerializer<MyProto_Empty>(),
        interceptors: self.interceptors?.makesendPlayInterceptors() ?? [],
        userFunction: self.sendPlay(request:context:)
      )

    case "updateSessionStatus":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_User>(),
        responseSerializer: ProtobufSerializer<MyProto_SessionStatus>(),
        interceptors: self.interceptors?.makeupdateSessionStatusInterceptors() ?? [],
        userFunction: self.updateSessionStatus(request:context:)
      )

    case "updateMessages":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_User>(),
        responseSerializer: ProtobufSerializer<MyProto_Message>(),
        interceptors: self.interceptors?.makeupdateMessagesInterceptors() ?? [],
        userFunction: self.updateMessages(request:context:)
      )

    case "updateBoard":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_User>(),
        responseSerializer: ProtobufSerializer<MyProto_Board>(),
        interceptors: self.interceptors?.makeupdateBoardInterceptors() ?? [],
        userFunction: self.updateBoard(request:context:)
      )

    case "updateTurn":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_User>(),
        responseSerializer: ProtobufSerializer<MyProto_User>(),
        interceptors: self.interceptors?.makeupdateTurnInterceptors() ?? [],
        userFunction: self.updateTurn(request:context:)
      )

    case "updateGameStatus":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_User>(),
        responseSerializer: ProtobufSerializer<MyProto_GameStatus>(),
        interceptors: self.interceptors?.makeupdateGameStatusInterceptors() ?? [],
        userFunction: self.updateGameStatus(request:context:)
      )

    default:
      return nil
    }
  }
}

/// To implement a server, implement an object which conforms to this protocol.
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
internal protocol MyProto_MessageServiceAsyncProvider: CallHandlerProvider, Sendable {
  static var serviceDescriptor: GRPCServiceDescriptor { get }
  var interceptors: MyProto_MessageServiceServerInterceptorFactoryProtocol? { get }

  func connect(
    request: MyProto_Empty,
    context: GRPCAsyncServerCallContext
  ) async throws -> MyProto_User

  func disconnect(
    request: MyProto_User,
    context: GRPCAsyncServerCallContext
  ) async throws -> MyProto_Empty

  func sendMessage(
    request: MyProto_Message,
    context: GRPCAsyncServerCallContext
  ) async throws -> MyProto_Empty

  func sendPlay(
    request: MyProto_Play,
    context: GRPCAsyncServerCallContext
  ) async throws -> MyProto_Empty

  func updateSessionStatus(
    request: MyProto_User,
    responseStream: GRPCAsyncResponseStreamWriter<MyProto_SessionStatus>,
    context: GRPCAsyncServerCallContext
  ) async throws

  func updateMessages(
    request: MyProto_User,
    responseStream: GRPCAsyncResponseStreamWriter<MyProto_Message>,
    context: GRPCAsyncServerCallContext
  ) async throws

  func updateBoard(
    request: MyProto_User,
    responseStream: GRPCAsyncResponseStreamWriter<MyProto_Board>,
    context: GRPCAsyncServerCallContext
  ) async throws

  func updateTurn(
    request: MyProto_User,
    responseStream: GRPCAsyncResponseStreamWriter<MyProto_User>,
    context: GRPCAsyncServerCallContext
  ) async throws

  func updateGameStatus(
    request: MyProto_User,
    responseStream: GRPCAsyncResponseStreamWriter<MyProto_GameStatus>,
    context: GRPCAsyncServerCallContext
  ) async throws
}

@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension MyProto_MessageServiceAsyncProvider {
  internal static var serviceDescriptor: GRPCServiceDescriptor {
    return MyProto_MessageServiceServerMetadata.serviceDescriptor
  }

  internal var serviceName: Substring {
    return MyProto_MessageServiceServerMetadata.serviceDescriptor.fullName[...]
  }

  internal var interceptors: MyProto_MessageServiceServerInterceptorFactoryProtocol? {
    return nil
  }

  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "connect":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_Empty>(),
        responseSerializer: ProtobufSerializer<MyProto_User>(),
        interceptors: self.interceptors?.makeconnectInterceptors() ?? [],
        wrapping: { try await self.connect(request: $0, context: $1) }
      )

    case "disconnect":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_User>(),
        responseSerializer: ProtobufSerializer<MyProto_Empty>(),
        interceptors: self.interceptors?.makedisconnectInterceptors() ?? [],
        wrapping: { try await self.disconnect(request: $0, context: $1) }
      )

    case "sendMessage":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_Message>(),
        responseSerializer: ProtobufSerializer<MyProto_Empty>(),
        interceptors: self.interceptors?.makesendMessageInterceptors() ?? [],
        wrapping: { try await self.sendMessage(request: $0, context: $1) }
      )

    case "sendPlay":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_Play>(),
        responseSerializer: ProtobufSerializer<MyProto_Empty>(),
        interceptors: self.interceptors?.makesendPlayInterceptors() ?? [],
        wrapping: { try await self.sendPlay(request: $0, context: $1) }
      )

    case "updateSessionStatus":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_User>(),
        responseSerializer: ProtobufSerializer<MyProto_SessionStatus>(),
        interceptors: self.interceptors?.makeupdateSessionStatusInterceptors() ?? [],
        wrapping: { try await self.updateSessionStatus(request: $0, responseStream: $1, context: $2) }
      )

    case "updateMessages":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_User>(),
        responseSerializer: ProtobufSerializer<MyProto_Message>(),
        interceptors: self.interceptors?.makeupdateMessagesInterceptors() ?? [],
        wrapping: { try await self.updateMessages(request: $0, responseStream: $1, context: $2) }
      )

    case "updateBoard":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_User>(),
        responseSerializer: ProtobufSerializer<MyProto_Board>(),
        interceptors: self.interceptors?.makeupdateBoardInterceptors() ?? [],
        wrapping: { try await self.updateBoard(request: $0, responseStream: $1, context: $2) }
      )

    case "updateTurn":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_User>(),
        responseSerializer: ProtobufSerializer<MyProto_User>(),
        interceptors: self.interceptors?.makeupdateTurnInterceptors() ?? [],
        wrapping: { try await self.updateTurn(request: $0, responseStream: $1, context: $2) }
      )

    case "updateGameStatus":
      return GRPCAsyncServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<MyProto_User>(),
        responseSerializer: ProtobufSerializer<MyProto_GameStatus>(),
        interceptors: self.interceptors?.makeupdateGameStatusInterceptors() ?? [],
        wrapping: { try await self.updateGameStatus(request: $0, responseStream: $1, context: $2) }
      )

    default:
      return nil
    }
  }
}

internal protocol MyProto_MessageServiceServerInterceptorFactoryProtocol: Sendable {

  /// - Returns: Interceptors to use when handling 'connect'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeconnectInterceptors() -> [ServerInterceptor<MyProto_Empty, MyProto_User>]

  /// - Returns: Interceptors to use when handling 'disconnect'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makedisconnectInterceptors() -> [ServerInterceptor<MyProto_User, MyProto_Empty>]

  /// - Returns: Interceptors to use when handling 'sendMessage'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makesendMessageInterceptors() -> [ServerInterceptor<MyProto_Message, MyProto_Empty>]

  /// - Returns: Interceptors to use when handling 'sendPlay'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makesendPlayInterceptors() -> [ServerInterceptor<MyProto_Play, MyProto_Empty>]

  /// - Returns: Interceptors to use when handling 'updateSessionStatus'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeupdateSessionStatusInterceptors() -> [ServerInterceptor<MyProto_User, MyProto_SessionStatus>]

  /// - Returns: Interceptors to use when handling 'updateMessages'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeupdateMessagesInterceptors() -> [ServerInterceptor<MyProto_User, MyProto_Message>]

  /// - Returns: Interceptors to use when handling 'updateBoard'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeupdateBoardInterceptors() -> [ServerInterceptor<MyProto_User, MyProto_Board>]

  /// - Returns: Interceptors to use when handling 'updateTurn'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeupdateTurnInterceptors() -> [ServerInterceptor<MyProto_User, MyProto_User>]

  /// - Returns: Interceptors to use when handling 'updateGameStatus'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeupdateGameStatusInterceptors() -> [ServerInterceptor<MyProto_User, MyProto_GameStatus>]
}

internal enum MyProto_MessageServiceServerMetadata {
  internal static let serviceDescriptor = GRPCServiceDescriptor(
    name: "MessageService",
    fullName: "myProto.MessageService",
    methods: [
      MyProto_MessageServiceServerMetadata.Methods.connect,
      MyProto_MessageServiceServerMetadata.Methods.disconnect,
      MyProto_MessageServiceServerMetadata.Methods.sendMessage,
      MyProto_MessageServiceServerMetadata.Methods.sendPlay,
      MyProto_MessageServiceServerMetadata.Methods.updateSessionStatus,
      MyProto_MessageServiceServerMetadata.Methods.updateMessages,
      MyProto_MessageServiceServerMetadata.Methods.updateBoard,
      MyProto_MessageServiceServerMetadata.Methods.updateTurn,
      MyProto_MessageServiceServerMetadata.Methods.updateGameStatus,
    ]
  )

  internal enum Methods {
    internal static let connect = GRPCMethodDescriptor(
      name: "connect",
      path: "/myProto.MessageService/connect",
      type: GRPCCallType.unary
    )

    internal static let disconnect = GRPCMethodDescriptor(
      name: "disconnect",
      path: "/myProto.MessageService/disconnect",
      type: GRPCCallType.unary
    )

    internal static let sendMessage = GRPCMethodDescriptor(
      name: "sendMessage",
      path: "/myProto.MessageService/sendMessage",
      type: GRPCCallType.unary
    )

    internal static let sendPlay = GRPCMethodDescriptor(
      name: "sendPlay",
      path: "/myProto.MessageService/sendPlay",
      type: GRPCCallType.unary
    )

    internal static let updateSessionStatus = GRPCMethodDescriptor(
      name: "updateSessionStatus",
      path: "/myProto.MessageService/updateSessionStatus",
      type: GRPCCallType.serverStreaming
    )

    internal static let updateMessages = GRPCMethodDescriptor(
      name: "updateMessages",
      path: "/myProto.MessageService/updateMessages",
      type: GRPCCallType.serverStreaming
    )

    internal static let updateBoard = GRPCMethodDescriptor(
      name: "updateBoard",
      path: "/myProto.MessageService/updateBoard",
      type: GRPCCallType.serverStreaming
    )

    internal static let updateTurn = GRPCMethodDescriptor(
      name: "updateTurn",
      path: "/myProto.MessageService/updateTurn",
      type: GRPCCallType.serverStreaming
    )

    internal static let updateGameStatus = GRPCMethodDescriptor(
      name: "updateGameStatus",
      path: "/myProto.MessageService/updateGameStatus",
      type: GRPCCallType.serverStreaming
    )
  }
}
